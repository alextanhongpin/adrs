# Idempotency


## Status

`draft`


## Context

### Definition

An operation is idempotent if executing it with the same request produces the same response. The execution happens exactly-once, as subsequent request will only return the cached response.

```
fn(key, req) -> res

fn: the idempotent function
key: the idempotency key
req: the request
res: the response
```

An idempotent operation is usually accompanied by an idempotency key to denote a unique operation.

The idempotency key, request and response is usually stored in a cache for a period of time. The retention period is not forever. After the retention period expired, the same request may be executed again. A permanent storage can be used as an alternative if we want to keep the operation permanently idempotent.

### Problem Statement


We want to implement idempotency to prevent issues with double requests. This can be for example, double withdrawal or double delivery of SMS.

The requests can be sth that does not have idempotency implemented, e.g. sms delivery, or may be expensive to execute multiple times, e.g. machine learning api request.

### Storage

Idempotency is just another form  of unique constraint in a relational database. By making a column unique, we can prevent new rows created that matches the column.

### Storing in table 

For most cases, we can keep the idempotent key in the same table, e.g. orders.

But for some, we might need a way to generate the unique identifier, e.g. when creating new payouts. This is because there will not be a fixed unique identifier when a new entity is created. For such scenario, we can for example generate a sequential identifier per user as the idempotent key. However, that is still not enough because multiple calls will then generate a new identifier. We can further limit the creation of the new payouts until the previous one has been completed. In short, we limit the user action instead, e.g. `user:1:create_payout`. Another option is to check the status, e.g. take the last count of the successful or failed payout. If there is already a pending payout, the sequential number will not be included, and hence will conflict (with the proper database constraints).

When creating idempotency operation, we follow the simple flow:

1. check if idempotency key exists (basically insert a new key and check the error)
2. check if the saved request matches the current request
3. return the saved response

If the idempotency key does not exists:

1. perform the idempotent operation
2. save the request and response

Ideally, each steps should be designed as idempotent to avoid complexity.

Idempotency is not the same as distributed locking. To achieve idempotency, we also need to implement locking to ensure that

1. the same operation is not conducted twice
2. access to the same resource is locked by a mutex
3. the request must match in order to return an already completed operation 

## Decision

### Using redis

Redis is a suitable option, since it is distributed and fast.

We use a distributed cache storage when the idempotent operation is an external call to a service that doesn't implement idempotency.

### Using postgres

For resource creation that resides in database, we can just set a unique constraint in the database.

### SLA

We will store the successful idempotency keys for 7-30 days, depending on the usecase. Note that for redis, if the swrvice restarts, all the data will be gone.

### Key name

The key name should be prefixed to avoid name collision.

The root prefix should be short, probably `i9y` for idempotency.

A second level prefix should indicate the idempotency operation name. This is to avoid mistakes with just using a resource id, which could span multiple operations.

Take for example, two operations that are related to orders, payment and refunds. If the operation prefix is not defined, and only the order id is used, there is a possibility of conflict when running the idempoteny operation.

Prefixing the operation makes it clear that they are two separate operation:

```
order-refund:order-123
order-payment:order-123
```

### Hashing the request

To save storage, we can hash the request payload. This also keeps the value secure since we do not keep sensitive values in the storage.

However, care need to be taken to handle the evolution of the value (adding or removing fields).

Hashing the request can be optional. The issue with hashing request is it is not easy to debug if there is a mismatch.

Conclusion:
- hash only if you have sensitive data
- hash only if you don't care about the values

### Idempotency value

The idempotency key is generated by concatenating a unique identified with the (hashed) request body.

The same idempotency keg will always return the same response. To retry the same request with the same identifier, just use a different body.

### Idempotency Goal

The goal in idempotency is to eliminate duplicate requests. However, they come in different categories. I have not found the best naming, but this is what i have seen so far

- identity based
- operation based
- sequential state

Identity based and operation based is probably the most common category we encounter day to day.

Identity operation usually involves an idempotency key that is based on the id of a resource, or could be hash of a payload. This could normally be handled in the database by setting a unique constraint in the column.

Operation based is an extension to identity based idempotency. For a given identity, we want to perform an operation only once. For example, we want to send an email once a day for a user with an email, so the idempotency key is `send-email:john.doe@mail.com:20230822`. For operation based idempotency, we also check the request to ensure it matches.


Sequential state is more complicated, but can happen for scenarios where an idempotency key cannot be based on a unique identifier, because the resource is not created yet. For example, when creating withdrawal for a user, we need to provide an idempotency key. However, every new withdrawal will actually generate a new idempotency key. This can be problematic, as we do not want users to be making many concurrent withdrawal requests, where the order of withdrawal may affect the balance. To ensure the withdrawal is done sequentially, we can introduce sequential state, where we used the last successful or failed withdrawal as the key for a given user, e.g. `payout:user:1:last_withdrawal_id`. This ensures that every withdrawal is successful or failed before the next one could be requested. This could also be a unique constraint within the database.

### Error handling

What happens if there is an error? Do we still store the request/response? Yes. The client will have to make a new request that is different from the previous one.

## Behaviour

Single operation, bounded by time
- request 1 enter
- request is cached
- request 2 enter
- error request in flight
- request 1 completed
- request 3 enter
- got cached response


  ### Metrics


  How do we measure the success of the idempotency operations?

Again, we can measure the idempotency hit and miss to understand how racy is the operation.
The ratio of hit should be high, to indicate that the data is always retrieved from the cache. If the count is low, it means it is just being saved once and not used much.

How do we test the success of this operation?

We can generate n requests for the same key, which contains duplicate and different parameters. We can then trigger a save to the database. By right, if it is idempotent, only one operation will save to the database. We can set a unique constraints in the sqlitedb to panic if an error occurs. We can simulate error saving to db.

We can do chaos testing with redis to simulate errors, to see the impact of failing redis to the save operations too.


### Articles

https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/

https://stripe.com/docs/api/idempotent_requests

https://developer.mastercard.com/mastercard-send-person-to-person/documentation/api-basics/

## Implementation 


Ideally the idempotency package should be storage (postgres, redis) independent.

The idea is to have a factory that takes a normal handler, and convert it into idempotent handler.


```
factory = redis_factory()
idempotent_handler = factory.make(handler, opts)
idempotent_handler.do(ctx, key, req)
```

### Redis

Implementation idempotency in redis is tricky, considering there is no built-in locking mechanism like postgres (e.g. advisory lock).

The `redlock` algo might work, but with additional complexity. We opt for a single node solution instead in order to customize the behavior.


We start with the data structure. We just use a simple string to store both the pending and completed state.

To acquire the lock, as well as returning the existing payload, we do:
```
# set or get
$ set <key> <token> nx get px <lock ttl ms>
nil: the value is set/does not exist
val: the existing value
```

This ensures both the set and get operation is atomic. Otherwise, there will be a dilemma between whether to get or set first in separate operations.

It value exists, we just need to check if it is a token uuid or a json body.

If it is a token uuid, it means another process is processing it. Otherwise, we check the json request to ensure it matches the existing request.

After acquiring the lock, we still need to extend it, in case the process takes longer than the lock timeout:

```
@every 7/10 of lock_ttl
extend(key, token, lock_ttl)
```

If an error occurs, we need to unlock, or wait for the timeout to expire:

```
unlock(key, token)
```

Otherwise, we process the function and replace the token uuid with the payload. We also update the ttl and specify how long to keep it 


```
replace(key, token, payload, keep_ttl)
```

At this point, the extend or unlock will fail because the token already changes.



## Consequences


