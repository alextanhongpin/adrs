# Idempotency


## Status

`draft`


## Context

### Definition

An operation is idempotent if executing it with the same request produces the same response. The execution happens exactly-once, as subsequent request will only return the cached response.

An idempotent operation is usually accompanied by an idempotency key to denote a unique operation.

The idempotency key, request and response is usually stored in a cache for a period of time. The retention period is not forever. After the retention period expired, the same request may be executed again. A permanent storage can be used as an alternative if we want to keep the operation permanently idempotent.

### Problem Statement


We want to implement idempotency to prevent issues with double requests. This can be for example, double withdrawal or double delivery of SMS.

### Storage

Idempotency is just another form  of unique constraint in a relational database. By making a column unique, we can prevent new rows created that matches the column.

### Storing in table 

For most cases, we can keep the idempotent key in the same table, e.g. orders.

But for some, we might need a way to generate the unique identifier, e.g. when creating new payouts. This is because there will not be a fixed unique identifier when a new entity is created. For such scenario, we can for example generate a sequential identifier per user as the idempotent key. However, that is still not enough because multiple calls will then generate a new identifier. We can further limit the creation of the new payouts until the previous one has been completed. In short, we limit the user action instead, e.g. `user:1:create_payout`. Another option is to check the status, e.g. take the last count of the successful or failed payout. If there is already a pending payout, the sequential number will not be included, and hence will conflict (with the proper database constraints).

When creating idempotency operation, we follow the simple flow:

1. check if idempotency key exists (basically insert a new key and check the error)
2. check if the saved request matches the current request
3. return the saved response

If the idempotency key does not exists:

1. perform the idempotent operation
2. save the request and response

Ideally, each steps should be designed as idempotent to avoid complexity.

Idempotency is not the same as distributed locking. To achieve idempotency, we also need to implement locking to ensure that

1. the same operation is not conducted twice
2. access to the same resource is locked by a mutex
3. the request must match in order to return an already completed operation 

## Decision

### Using redis

Redis is a suitable option, since it is distributed and fast.

We use a distributed cache storage when the idempotent operation is an external call to a service that doesn't implement idempotency.

### Using postgres

For resource creation that resides in database, we can just set a unique constraint in the database.

### SLA

We will store the successful idempotency keys for 7-30 days, depending on the usecase. Note that for redis, if the swrvice restarts, all the data will be gone.

### Key name

The key name should be prefixed to avoid name collision.

The root prefix should be short, probably `i9y` for idempotency.

A second level prefix should indicate the idempotency operation name. This is to avoid mistakes with just using a resource id, which could span multiple operations.

Take for example, two operations that are related to orders, payment and refunds. If the operation prefix is not defined, and only the order id is used, there is a possibility of conflict when running the idempoteny operation.

Prefixing the operation makes it clear that they are two separate operation:

```
order-refund:order-123
order-payment:order-123
```

### Hashing the request

To save storage, we can hash the request payload. This also keeps the value secure since we do not keep sensitive values in the storage.

However, care need to be taken to handle the evolution of the value (adding or removing fields).

Hashing the request can be optional. The issue with hashing request is it is not easy to debug if there is a mismatch.

Conclusion:
- hash only if you have sensitive data
- hash only if you don't care about the values

### Idempotency value

The idempotency key is generated by concatenating a unique identified with the (hashed) request body.

The same idempotency keg will always return the same response. To retry the same request with the same identifier, just use a different body.

### Idempotency Goal

The goal in idempotency is to eliminate duplicate requests. However, they come in different categories. I have not found the best naming, but this is what i have seen so far

- identity based
- operation based
- sequential state

Identity based and operation based is probably the most common category we encounter day to day.

Identity operation usually involves an idempotency key that is based on the id of a resource, or could be hash of a payload. This could normally be handled in the database by setting a unique constraint in the column.

Operation based is an extension to identity based idempotency. For a given identity, we want to perform an operation only once. For example, we want to send an email once a day for a user with an email, so the idempotency key is `send-email:john.doe@mail.com:20230822`. For operation based idempotency, we also check the request to ensure it matches.


Sequential state is more complicated, but can happen for scenarios where an idempotency key cannot be based on a unique identifier, because the resource is not created yet. For example, when creating withdrawal for a user, we need to provide an idempotency key. However, every new withdrawal will actually generate a new idempotency key. This can be problematic, as we do not want users to be making many concurrent withdrawal requests, where the order of withdrawal may affect the balance. To ensure the withdrawal is done sequentially, we can introduce sequential state, where we used the last successful or failed withdrawal as the key for a given user, e.g. `payout:user:1:last_withdrawal_id`. This ensures that every withdrawal is successful or failed before the next one could be requested. This could also be a unique constraint within the database.

### Error handling

What happens if there is an error? Do we still store the request/response? Yes. The client will have to make a new request that is different from the previous one.



### Articles

https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/

https://stripe.com/docs/api/idempotent_requests

https://developer.mastercard.com/mastercard-send-person-to-person/documentation/api-basics/

## Consequences


